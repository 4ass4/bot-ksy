import Database from '../database/database.js';
import { SocialIntegration, SocialPost, SocialPlatform, PostType } from '../types/index.js';

export class SocialService {
  constructor(private db: Database) {}

  // –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π
  async createIntegration(
    platform: SocialPlatform,
    accessToken?: string,
    refreshToken?: string,
    userId?: string
  ): Promise<SocialIntegration> {
    const result = await this.db.run(`
      INSERT INTO social_integrations (platform, access_token, refresh_token, user_id)
      VALUES (?, ?, ?, ?)
    `, [platform, accessToken, refreshToken, userId]);

    return {
      id: result.lastID!,
      platform,
      access_token: accessToken,
      refresh_token: refreshToken,
      user_id: userId,
      is_active: true,
      created_at: new Date(),
      updated_at: new Date()
    };
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –¥–ª—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
  async getActiveIntegration(platform: SocialPlatform): Promise<SocialIntegration | null> {
    const result = await this.db.get<any>(`
      SELECT * FROM social_integrations 
      WHERE platform = ? AND is_active = TRUE
      ORDER BY created_at DESC
      LIMIT 1
    `, [platform]);

    if (!result) return null;

    return {
      ...result,
      created_at: new Date(result.created_at),
      updated_at: new Date(result.updated_at)
    };
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
  async updateIntegration(
    integrationId: number,
    accessToken?: string,
    refreshToken?: string,
    isActive?: boolean
  ): Promise<void> {
    const updates = [];
    const values = [];

    if (accessToken !== undefined) {
      updates.push('access_token = ?');
      values.push(accessToken);
    }
    if (refreshToken !== undefined) {
      updates.push('refresh_token = ?');
      values.push(refreshToken);
    }
    if (isActive !== undefined) {
      updates.push('is_active = ?');
      values.push(isActive);
    }

    updates.push('updated_at = ?');
    values.push(new Date().toISOString());
    values.push(integrationId);

    await this.db.run(`
      UPDATE social_integrations 
      SET ${updates.join(', ')}
      WHERE id = ?
    `, values);
  }

  // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Å—Ç–∞ –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏
  async createPost(
    platform: SocialPlatform,
    postType: PostType,
    content?: string,
    mediaFileId?: string,
    raffleId?: number,
    scheduledAt?: Date
  ): Promise<SocialPost> {
    const status = scheduledAt ? 'SCHEDULED' : 'DRAFT';
    
    const result = await this.db.run(`
      INSERT INTO social_posts (platform, post_type, content, media_file_id, raffle_id, status, scheduled_at)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [platform, postType, content, mediaFileId, raffleId, status, scheduledAt?.toISOString()]);

    return {
      id: result.lastID!,
      platform,
      post_type: postType,
      content,
      media_file_id: mediaFileId,
      raffle_id: raffleId,
      status,
      scheduled_at: scheduledAt,
      created_at: new Date()
    };
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤ –ø–æ —Å—Ç–∞—Ç—É—Å—É
  async getPostsByStatus(status: string, platform?: SocialPlatform): Promise<SocialPost[]> {
    let query = 'SELECT * FROM social_posts WHERE status = ?';
    const values = [status];

    if (platform) {
      query += ' AND platform = ?';
      values.push(platform);
    }

    query += ' ORDER BY created_at DESC';

    const results = await this.db.all<any>(query, values);

    return results.map(result => ({
      ...result,
      created_at: new Date(result.created_at),
      scheduled_at: result.scheduled_at ? new Date(result.scheduled_at) : undefined,
      published_at: result.published_at ? new Date(result.published_at) : undefined
    }));
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ—Å—Ç–∞
  async updatePostStatus(postId: number, status: string, externalPostId?: string): Promise<void> {
    const updates = ['status = ?'];
    const values = [status];

    if (status === 'PUBLISHED') {
      updates.push('published_at = ?');
      values.push(new Date().toISOString());
    }

    if (externalPostId) {
      updates.push('external_post_id = ?');
      values.push(externalPostId);
    }

    values.push(postId.toString());

    await this.db.run(`
      UPDATE social_posts 
      SET ${updates.join(', ')}
      WHERE id = ?
    `, values);
  }

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –¥–ª—è –ø–æ—Å—Ç–∞ –æ —Ä–æ–∑—ã–≥—Ä—ã—à–µ
  generateRafflePostContent(raffle: any, channels: any[]): string {
    const channelNames = channels.map(c => c.name).join(', ');
    
    return `üéÅ *–ù–æ–≤—ã–π —Ä–æ–∑—ã–≥—Ä—ã—à!*

üèÜ –ü—Ä–∏–∑: ${raffle.prize_description}
üë• –ü–æ–±–µ–¥–∏—Ç–µ–ª–µ–π: ${raffle.winners_count}
‚è∞ –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ: ${new Date(raffle.end_date).toLocaleDateString('ru-RU')}

üì∫ –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª—ã: ${channelNames}

üéØ –£—á–∞—Å—Ç–≤—É–π—Ç–µ –∏ –≤—ã–∏–≥—Ä—ã–≤–∞–π—Ç–µ!`;
  }

  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –¥–ª—è –ø–æ—Å—Ç–∞ –æ –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ
  generateWinnerPostContent(winner: any, raffle: any): string {
    return `üèÜ *–ü–æ–±–µ–¥–∏—Ç–µ–ª—å —Ä–æ–∑—ã–≥—Ä—ã—à–∞!*

üéÅ –ü—Ä–∏–∑: ${raffle.prize_description}
üë§ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: @${winner.username || winner.first_name}
üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!

üí° –°–ª–µ–¥–∏—Ç–µ –∑–∞ –Ω–æ–≤—ã–º–∏ —Ä–æ–∑—ã–≥—Ä—ã—à–∞–º–∏!`;
  }

  // –ü—É–±–ª–∏–∫–∞—Ü–∏—è –ø–æ—Å—Ç–∞ –≤ Telegram (–≤—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è)
  async publishToTelegram(post: SocialPost, bot: any): Promise<boolean> {
    try {
      if (!post.content) return false;

      // –ü—É–±–ª–∏–∫—É–µ–º –≤ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –∫–∞–Ω–∞–ª, –µ—Å–ª–∏ –µ—Å—Ç—å
      const officialChannel = await this.getOfficialChannel();
      if (officialChannel) {
        const messageOptions: any = {
          parse_mode: 'Markdown'
        };

        if (post.media_file_id) {
          await bot.api.sendPhoto(officialChannel.telegram_channel_id, post.media_file_id, {
            caption: post.content,
            ...messageOptions
          });
        } else {
          await bot.api.sendMessage(officialChannel.telegram_channel_id, post.content, messageOptions);
        }

        await this.updatePostStatus(post.id, 'PUBLISHED', 'telegram');
        return true;
      }

      return false;
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤ Telegram:', error);
      await this.updatePostStatus(post.id, 'FAILED');
      return false;
    }
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞
  private async getOfficialChannel(): Promise<any> {
    return await this.db.get('SELECT * FROM official_channel LIMIT 1');
  }

  // –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–æ–≤
  async schedulePost(
    platform: SocialPlatform,
    postType: PostType,
    content: string,
    scheduledAt: Date,
    mediaFileId?: string,
    raffleId?: number
  ): Promise<SocialPost> {
    return await this.createPost(platform, postType, content, mediaFileId, raffleId, scheduledAt);
  }

  // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ—Å—Ç–æ–≤
  async getPostStats(): Promise<{
    totalPosts: number;
    publishedPosts: number;
    failedPosts: number;
    scheduledPosts: number;
    postsByPlatform: Array<{ platform: string; count: number }>;
  }> {
    const stats = await this.db.get<any>(`
      SELECT 
        COUNT(*) as total_posts,
        SUM(CASE WHEN status = 'PUBLISHED' THEN 1 ELSE 0 END) as published_posts,
        SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failed_posts,
        SUM(CASE WHEN status = 'SCHEDULED' THEN 1 ELSE 0 END) as scheduled_posts
      FROM social_posts
    `);

    const postsByPlatform = await this.db.all<any>(`
      SELECT platform, COUNT(*) as count
      FROM social_posts
      GROUP BY platform
      ORDER BY count DESC
    `);

    return {
      totalPosts: stats?.total_posts || 0,
      publishedPosts: stats?.published_posts || 0,
      failedPosts: stats?.failed_posts || 0,
      scheduledPosts: stats?.scheduled_posts || 0,
      postsByPlatform: postsByPlatform || []
    };
  }
} 